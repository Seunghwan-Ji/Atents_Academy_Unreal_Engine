1. 캐릭터를 조작하기 위해서는 우선 게임모드 베이스 클래스를 추가해야함.
- 콘텐츠 드로어 -> 블루프린트 클래스 -> 게임모드 베이스 클래스.
- 이름 예: BP_GameMode
2. BP_GameMode 에서 디폴트 폰 클래스를 내가 만든 캐릭터 클래스로 지정해줌.
- 캐릭터 클래스는 폰 클래스를 상속 받은 클래스이기 때문에 폰 클래스 목록에 나옴.
3. 만든 게임모드 베이스 클래스는 콘텐츠 드로어에서 드래그해서 월드에 배치할 수 없음. 프로젝트 세팅 -> 맵&모드 -> 기본 게임모드에서 내가 만든 게임모드 베이스 클래스를 지정해줘야됨.
4. 캐릭터 클래스에서 카메라 컴포넌트를 추가하면 플레이 시 그 캐릭터를 추적할 수 있음.
- 컴포넌트 탭에서 추가 -> Camera.
- 디테일 탭에서 트랜스폼을 조정해 캐릭터를 보는 각도 설정 가능.
5. 캐릭터를 조작하기 위해서는 플레이어 컨트롤러 클래스를 추가해야함.
- 콘텐츠 드로어 -> 블루프린트 클래스 -> 플레이어 컨트롤러 클래스.
- 이름 예: BP_PlayerController
6. 플레이어 컨트롤러 클래스 객체 생성 방식은 BP_GameMode 의 플레이어 컨트롤러 클래스에서 BP_PlayerController 를 지정해주면됨.
7. 다음으로 움직임의 종류를 정의해야함. 콘텐츠 드로어에서 추가 -> 입력 -> 입력 액션.
- 이름 예: IA_Move
8. 트리거 항목에서 + 버튼을 클릭하면 어떤 입력 방식을 받을 것인지 선택할 수 있음.
- 길게 누르기: 키를 길게 눌렀을 때 특정 기능이 발동됨.
- 길게 누르기 및 해제: 키를 길게 눌렀다 뗐을 때 특정 기능이 발동됨.
- 눌림: 키가 눌린 순간에 특정 기능이 발동됨.
- 다운: 키가 눌려있는 동안 계속 특정 기능이 발동됨.
- 해제됨: 키를 뗐을 때 특정 기능이 발동됨.
- 탭: 키를 빠르게 눌렀다 뗐을 때 특정 기능이 발동됨.
- 펄스: 키를 눌렀을 때 지속적으로 주기마다 특정 기능이 발동됨.
- 코딩된 액션: 여러 키를 조합해서 눌러야 특정 기능이 발동됨.
9. 액션 항목에서 받는 값 타입을 선택할 수 있음.
- 예:
- 2차원 벡터: 입력 장치에서 들어오는 값을 2차원 벡터로 해석.
- 3차원 벡터: 입력 장치에서 들어오는 값을 3차원 벡터로 해석.
10. 다음으로 키를 맵핑 해줘야함. 콘텐츠 드로어에서 추가 -> 입력 -> 입력 매핑 컨텍스트.
- 이름 예: IMC_Default
11. 매핑 항목에서 + 버튼을 누르고 내가 만든 입력 액션을 선택하고 오른쪽에 + 버튼 클릭하여 키 추가.
- 예: W, S, D, A
12. S 키 항목의 모디파이어 항목에서 + 버튼을 클릭하고 부정을 선택.
13. D 키 항목과 A 키 항목의 모디파이어 항목에서 + 버튼을 클릭하고 스위즐 입력 축 값 선택.
14. A 키 항목의 모디파이어 항목에서 + 버튼을 클릭하고 부정 선택.
- 입력 액션이 3차원 벡터 타입을 받는다고 가정할 때, X, Y, Z 3채널 형태로 받게 되는데, 기본적으로 어떤 키를 눌러도 X 자리에 값이 들어옴.
- D, A 키는 모디파이어가 스위즐인데 스위즐은 뒤섞다 라는 뜻임. 모디파이어 항목의 인덱스 항목을 보면 YXZ 라고 나옴. 즉, 이 두 키는 X, Y, Z 를 뒤섞어서 Y, X, Z 형태로 받게됨.
- 따라서 W, S 키는 값이 X 자리에 들어오고, D, A 키는 값이 Y 자리에 들어옴.
- 기본적으로 키보드 입력은 눌렀을 때 1, 뗐을 때 0임.
- S 키와 A 키를 부정으로 해준 이유는 1을 받는게 아닌 -1로 받게 함으로써 1을 받는 키들과 구분하기 위해서임.
- 따라서 W, S 키는 똑같이 X 에서 값을 받지만, 구분되었기 때문에 서로 반대 방향으로 캐릭터를 움직이게 할 수 있고, D, A 키는 똑같이 Y 에서 값을 받지만, 구분되었기 때문에 서로 반대 방향으로 캐릭터를 움직이게 할 수 있음.
15. 플레이어 컨트롤러 클래스 이벤트 그래프 내에서 우클릭 -> EnhancedInputLocalPlayerSubsystem 노드 추가 -> 입력 핀을 끌어서 놓은 다음에 -> AddMappingContext 노드 추가.
- EnhancedInputLocalPlayerSubsystem 는 엔진이 가지고 있는 내용이고, 엔진이 매핑 컨텍스트의 내용을 읽게됨.
16. 다음으로 Mapping Context 를 내가 만든 입력 매핑 컨텍스트로 선택하고, BeginPlay 노드의 출력핀을 AddMappingContext 노드의 입력핀과 연결.
17. 입력 액션은 입력 매핑 컨텍스트를 해석해서 벡터값(예: 3차원 벡터)으로 반환하게 되는데, 이 값을 쓸 수 있게하는 이벤트 노드가 있음.
- 이벤트 그래프 내에서 우클릭 내가 만든 입력 액션의 이름을 검색하면 EnhancedInputAction 으로 시작하는 것을 선택 후 노드 생성.
18. 입력 액션이 다운이라고 가정했을 때, Started 출력핀은 키가 눌리기 시작했을 때, Triggerd 출력핀은 키가 눌리는 동안에, Complited 출력핀은 키가 떼졌을 때 실행됨.
19. 노드 검색에서 getpawn 을 검색해서 선택하면 컨트롤러가 제어중인 캐릭터를 반환하는 GetControlledPawn 노드가 생성됨.
20. 이 노드의 출력핀을 끌어서 놓은다음, AddMovementInput 노드 추가.
21. EnhancedInputLocalPlayerSubsystem 노드의 Triggerd 출력핀을 AddMovementInput 노드의 입력핀에 연결.
22. ActionValue 출력핀을 WorldDirection 입력핀에 연결.
- ActionValue 가 입력 액션이 반환한 벡터값임.
23. 특정 노드들은 Target is ** 이라는 구문이 새겨져 있는데 ** 은 클래스이고 노드가 그 클래스의 멤버 함수라는 뜻임.
24. 핀을 끌어서 놓아야 검색할 수 있는 노드들에 대해서.
- 예를들어 GetControlledPawn 노드에서 핀을 끌어서 놓고 AddMovementInput 노드 함수를 호출한다고 가정함.
- GetControlledPawn 은 Pawn 의 주소를 반환함.
- AddMovementInput 함수는 Pawn 객체가 속한 클래스의 멤버 함수임.
- 즉, 다른 클래스의 멤버 함수는 그 클래스에 속한 객체의 주소를 받아서 호출해야되기 때문에 객체의 주소를 반환하는 노드의 핀을 끌어다 놓아야됨. 